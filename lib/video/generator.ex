defmodule Video.Generator do
  # TODO ideally this would be the type of a class implementing the behaviour
  @type t() :: module()

  @autogen_module_name "Elixir.Data.AutoGenerated.Video.Rendered_"
  @autogen_file_path "data/auto_generated/video"

  import Guards

  @doc """
  Return a list of all known videos, including the ones without video material
  available.
  """
  @spec all() :: [t()]
  def all() do
    Util.modules_with_prefix(@autogen_module_name)
    |> Enum.sort()
  end

  @doc """
  Tries to find a fully rendered video for the given hash or track. It returns
  nil if the hash is invalid, the video cannot be found or has not been rendered
  yet. Note that you need to recompile if videos were rendered in the meantime.
  """
  @typep rendered_identifer :: Video.Track.t() | Video.Track.hash() | module()
  @spec get(rendered_identifer | [rendered_identifer]) :: t() | nil
  def get(nil), do: nil

  def get(hash) when valid_hash(hash) do
    try do
      mod = String.to_existing_atom(@autogen_module_name <> hash)
      if mod.rendered?(), do: mod, else: nil
    rescue
      ArgumentError ->
        # i.e. doesn't exist
        nil
    end
  end

  def get(module) when is_atom(module), do: if(module.rendered?(), do: module, else: nil)

  def get(%Video.Track{renderer: renderer, videos: videos}) do
    Enum.find(all(), fn rendered ->
      rendered.renderer() == renderer && rendered.sources() == videos
    end)
  end

  def get(list) when is_list(list) do
    list
    |> Enum.map(&get/1)
    |> Enum.uniq()
    |> Util.compact()
  end

  def get(_any), do: nil

  @doc """
  Same as get, but uses a different return style pattern.
  """
  @spec get_error(Video.Track.t() | Video.Track.hash() | module()) ::
          {:ok, t()} | {:error, binary()}
  def get_error(hash) do
    with res when not is_nil(res) <- get(hash) do
      {:ok, res}
    else
      _ -> {:error, "no module found with found by '#{inspect(hash)}'"}
    end
  end

  @spec find_by_hash(Video.Track.hash()) :: t() | nil
  def find_by_hash(hash) when valid_hash(hash) do
    all() |> Enum.find(fn mod -> String.ends_with?("#{mod}", hash) end)
  end

  def find_by_hash(_any), do: nil

  @doc """
  Return a list of all videos which have video material available.
  """
  @spec rendered() :: [t()]
  def rendered() do
    all() |> Enum.filter(& &1.rendered?())
  end

  @doc """
  Return a list of all videos for which video material still needs to be generated.
  """
  @spec pending() :: [t()]
  def pending() do
    all() |> Enum.reject(& &1.rendered?())
  end

  @doc """
  Returns the path to the autogenerated video metadata for the given TSV or
  rendered module itself.
  """
  @spec path(Video.Track.hash() | t()) ::
          binary() | {:error, binary()}
  def path(hash) when valid_hash(hash) do
    Path.join(@autogen_file_path, "#{hash}.ex")
  end

  def path(module) when is_atom(module) do
    mod_as_str = to_string(module)

    if String.starts_with?(mod_as_str, @autogen_module_name) do
      hash = String.replace_prefix(mod_as_str, @autogen_module_name, "")
      path(hash)
    else
      {:error, "#{module} is not a Rendered instance"}
    end
  end

  @doc """
  Render the given trimmed sequence as a rendered video, then save it to disk
  at the matching path.
  """
  @spec save_from_track(Video.Track.t()) ::
          :ok | {:error, binary()} | {:error, list(), list()}
  def save_from_track(%{videos: nil}), do: :ok

  def save_from_track(track) do
    with {hash, coords, recording_dates, street_names} <- Video.Track.render(track) do
      path = path(hash)

      name =
        cond do
          is_binary(track.parent_ref) ->
            "#{track.parent_ref}: #{track.text}"

          is_atom(track.parent_ref) && !is_nil(track.parent_ref) ->
            "#{track.parent_ref.name()}: #{track.text}"

          true ->
            track.text
        end

      with content <-
             as_code(
               name,
               hash,
               track.videos,
               coords,
               recording_dates,
               street_names,
               track.renderer
             ),
           :ok <- Util.write_autogenerated_file(path, content) do
        module_name(hash)
      end
    end
  end

  @doc """
  Render the given trimmed sequence as a rendered video, but only make it
  available in the current runtime. No files are being written.
  """
  @spec dynamic_compile(Video.Track.t()) ::
          :ok | {:error, binary()} | {:error, list(), list()}
  def dynamic_compile(track) do
    with {hash, coords, rec_dates, street_names} <- Video.Track.render(track) do
      mod_name = Video.Generator.find_by_hash(hash)

      if is_nil(mod_name) do
        [{mod_name, _bytes}] =
          as_code(
            "dynamic_compile",
            hash,
            track.videos,
            coords,
            rec_dates,
            street_names,
            track.renderer
          )
          |> Enum.join()
          |> Code.compile_string()

        mod_name
      else
        mod_name
      end
    end
  end

  @spec module_name(Video.Track.hash()) :: module()
  def module_name(hash) when valid_hash(hash) do
    :"#{@autogen_module_name}#{hash}"
  end

  @polyline_interval_ms 1000.0 / 60.0
  @polyline_precision 6
  defp as_code(name, hash, sources, coords, recording_dates, street_names, renderer) do
    length_ms = coords |> List.last() |> Map.fetch!(:time_offset_ms)
    rendered = Video.Path.fully_rendered?(hash)
    bbox = Geo.CheapRuler.bbox(coords)

    polyline = %{
      polyline: Geo.Smoother.polyline(coords, @polyline_interval_ms, @polyline_precision),
      interval: @polyline_interval_ms,
      precision: @polyline_precision
    }

    quote do
      defmodule unquote(module_name(hash)) do
        @moduledoc """
        #{unquote(name)}

        # AUTOGENERATED. To update this file, run mix velo.videos.generate.
        # See Video.Rendered for functionality.
        """

        @behaviour Video.Rendered

        @impl Video.Rendered
        def name(), do: unquote(Macro.escape(name))
        @impl Video.Rendered
        def hash(), do: unquote(Macro.escape(hash))
        @impl Video.Rendered
        def length_ms(), do: unquote(Macro.escape(length_ms))
        @impl Video.Rendered
        def sources(), do: unquote(Macro.escape(sources))
        @impl Video.Rendered
        def rendered?(), do: unquote(rendered)
        @impl Video.Rendered
        def bbox(), do: unquote(bbox)
        @impl Video.Rendered
        def renderer(), do: unquote(renderer)
        @impl Video.Rendered
        def recording_dates(), do: unquote(recording_dates)
        @impl Video.Rendered
        # names derived from OpenStreetMap data, thus ODbL https://osmfoundation.org/wiki/Licence
        def street_names(), do: unquote(street_names)
        @impl Video.Rendered
        def coords(), do: unquote(coords)
        @impl Video.Rendered
        def polyline(), do: unquote(Macro.escape(polyline))
      end
    end
    |> Macro.to_string()
    |> Code.format_string!()
    |> Kernel.++(["\n"])
  end

  @doc """
  Returns the recording data string for the given timestamp

  ## Examples

      iex> Video.Generator.recording_date_for(Video.GeneratorTest.Example, 11)
      "after ten ms"
  """
  @spec recording_date_for(t(), non_neg_integer()) :: binary()
  def recording_date_for(rendered, time_in_ms) when time_in_ms >= 0 do
    Enum.reduce_while(rendered.recording_dates(), "", fn %{timestamp: ts, text: binary}, prev ->
      if ts <= time_in_ms, do: {:cont, binary}, else: {:halt, prev}
    end)
  end

  @doc """
  Returns the street name for the given timestamp

  ## Examples

      iex> Video.Generator.street_name_for(Video.GeneratorTest.Example, 11)
      "after ten ms"
  """
  @spec street_name_for(t(), non_neg_integer()) :: binary()
  def street_name_for(rendered, time_in_ms) when time_in_ms >= 0 do
    Enum.reduce_while(rendered.street_names(), "", fn %{timestamp: ts, text: binary}, prev ->
      if ts <= time_in_ms, do: {:cont, binary}, else: {:halt, prev}
    end)
  end

  @type indicator :: %{
          lat: float(),
          lon: float(),
          bearing: float(),
          time_offset_ms: non_neg_integer()
        }

  @spec start_from(t(), Geo.Point.like() | integer() | nil) :: indicator()
  @doc """
  Find the closest point for the video that roughly corresponds to the given
  point or timestmap. If the point is not valid, it returns the start of the
  video.

  ## Examples

      iex> Video.Generator.start_from(Video.GeneratorTest.Example, %{lat: 53.5085, lon: 10.041})
      %{bearing: 310.0161346069299, lat: 53.5085, lon: 10.041000000000002, time_offset_ms: 150}

      iex> last_coord = Video.GeneratorTest.Example.coords() |> List.last()
      iex> Video.Generator.start_from(Video.GeneratorTest.Example, last_coord)
      %{bearing: 310.01613460713037, lat: last_coord.lat, lon: last_coord.lon, time_offset_ms: last_coord.time_offset_ms}

      iex> Video.Generator.start_from(Video.GeneratorTest.Example, 124)
      %{bearing: 310.0161346069299, lat: 53.50824, lon: 10.04152, time_offset_ms: 124}
  """
  def start_from(rendered, point_or_time)

  def start_from(rendered, nil) do
    [a, b | _rest] = rendered.coords
    Map.put(a, :bearing, Geo.CheapRuler.bearing(a, b))
  end

  def start_from(rendered, time) when is_integer(time) do
    cond do
      time <= 0 ->
        start_from(rendered, nil)

      time >= rendered.length_ms() ->
        [a, b] = rendered.coords() |> Enum.slice(-2..-1)
        Map.put(b, :bearing, Geo.CheapRuler.bearing(a, b))

      true ->
        rendered.coords()
        |> Stream.chunk_every(2, 1, :discard)
        |> Stream.filter(fn [a, b] -> time >= a.time_offset_ms && time <= b.time_offset_ms end)
        |> Enum.find_value(fn [a, b] ->
          t = calc_t(time, a, b)

          Video.TimedPoint.interpolate(a, b, t)
          |> Map.put(:bearing, Geo.CheapRuler.bearing(a, b))
          |> Map.delete(:__struct__)
        end)
    end || start_from(rendered, nil)
  end

  def start_from(rendered, point) do
    %{point: %{lon: lon, lat: lat}, t: t, index: idx} =
      Geo.CheapRuler.closest_point_on_line(rendered.coords, point)

    {idx, time} =
      if idx == length(rendered.coords) - 1 do
        {idx - 1, Enum.at(rendered.coords, idx).time_offset_ms}
      else
        {idx, nil}
      end

    [prev, next] = Enum.slice(rendered.coords, idx..(idx + 1))
    bearing = Geo.CheapRuler.bearing(prev, next)
    time = time || prev.time_offset_ms + t * (next.time_offset_ms - prev.time_offset_ms)

    %{
      lon: lon,
      lat: lat,
      bearing: bearing,
      time_offset_ms: round(time)
    }
  end

  defp calc_t(interp, prev, next),
    do: (interp - prev.time_offset_ms) / (next.time_offset_ms - prev.time_offset_ms)
end
