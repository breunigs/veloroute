defmodule Video.Generator do
  @autogen_module_name "Elixir.Data.AutoGenerated.Video.Rendered_"
  @autogen_file_path "data/auto_generated/video"

  import Guards

  @doc """
  Return a list of all known videos, including the ones without video material
  available.
  """
  @spec all() :: [Video.Rendered.t()]
  def all() do
    Util.modules_with_prefix(@autogen_module_name)
    |> Enum.sort()
  end

  @doc """
  Tries to find a fully rendered video for the given hash or track. It returns
  nil if the hash is invalid, the video cannot be found or has not been rendered
  yet. Note that you need to recompile if videos were rendered in the meantime.
  """
  @typep rendered_identifer ::
           Video.Track.t() | Video.Track.hash() | module() | Video.Rendered.vanity()
  @spec get(rendered_identifer | [rendered_identifer]) :: Video.Rendered.t() | nil
  def get(nil), do: nil

  def get(hash) when valid_hash(hash) do
    try do
      mod = String.to_existing_atom(@autogen_module_name <> hash)
      if mod.rendered?(), do: mod, else: nil
    rescue
      ArgumentError ->
        # i.e. doesn't exist
        nil
    end
  end

  def get(module) when is_module(module), do: if(module.rendered?(), do: module, else: nil)

  def get(%Video.Track{historic: hist}) when is_map(hist) and not is_map_key(hist, "") do
    {hash, _date} =
      Enum.reduce(hist, fn {hash, date}, {prev_hash, prev_date} ->
        if Data.RoughDate.compare(prev_date, date) == :gt,
          do: {prev_hash, prev_date},
          else: {hash, date}
      end)

    get(hash)
  end

  def get(%Video.Track{renderer: renderer, videos: videos}) do
    Enum.find(all(), fn rendered ->
      rendered.renderer() == renderer && rendered.sources() == videos
    end)
  end

  def get(list) when is_list(list) do
    list
    |> Enum.map(&get/1)
    |> Enum.uniq()
    |> Util.compact()
  end

  @vanity_id_length Video.Rendered.vanity_id_length()
  def get(<<abbrev_hash::binary-size(@vanity_id_length)>> <> "-" <> vanity) do
    mod =
      Util.modules_with_prefix(@autogen_module_name <> abbrev_hash)
      |> Enum.filter(&String.starts_with?(&1.name(), vanity <> ":"))
      |> Enum.sort()
      |> List.first()

    if mod.rendered?(), do: mod
  end

  def get(_any), do: nil

  @doc """
  Same as get, but uses a different return style pattern.
  """
  @spec get_error(Video.Track.t() | Video.Track.hash() | module()) ::
          {:ok, Video.Rendered.t()} | {:error, binary()}
  def get_error(hash) do
    with res when not is_nil(res) <- get(hash) do
      {:ok, res}
    else
      _ -> {:error, "no module found with found by '#{inspect(hash)}'"}
    end
  end

  @spec find_by_hash(Video.Track.hash()) :: Video.Rendered.t() | nil
  def find_by_hash(hash) when valid_hash(hash) do
    all() |> Enum.find(fn mod -> String.ends_with?("#{mod}", hash) end)
  end

  def find_by_hash(_any), do: nil

  @doc """
  Return a list of all videos which have video material available.
  """
  @spec rendered() :: [Video.Rendered.t()]
  def rendered() do
    all() |> Enum.filter(& &1.rendered?())
  end

  @doc """
  Return a list of all videos for which video material still needs to be generated.
  """
  @spec pending() :: [Video.Rendered.t()]
  def pending() do
    all() |> Enum.reject(& &1.rendered?())
  end

  @doc """
  Returns the path to the autogenerated video metadata for the given TSV or
  rendered module itself.
  """
  @spec path(Video.Track.hash() | Video.Rendered.t()) :: binary() | {:error, binary()}
  def path(hash) when valid_hash(hash) do
    Path.join(@autogen_file_path, "#{hash}.ex")
  end

  def path(module) when is_atom(module) do
    mod_as_str = to_string(module)

    if String.starts_with?(mod_as_str, @autogen_module_name) do
      hash = String.replace_prefix(mod_as_str, @autogen_module_name, "")
      path(hash)
    else
      {:error, "#{module} is not a Rendered instance"}
    end
  end

  @doc """
  Render the given trimmed sequence as a rendered video, then save it to disk
  at the matching path.
  """
  @spec save_from_track(Video.Track.t()) ::
          :ok | {:error, binary()} | {:error, list(), list()}
  def save_from_track(%{videos: nil}), do: :ok

  def save_from_track(track) do
    with {hash, coords, recording_dates, street_names} <- Video.Track.render(track) do
      path = path(hash)

      name =
        cond do
          is_binary(track.parent_ref) ->
            "#{track.parent_ref}: #{track.text}"

          is_atom(track.parent_ref) && !is_nil(track.parent_ref) ->
            "#{track.parent_ref.name()}: #{track.text}"

          true ->
            track.text
        end

      with content <-
             as_code(
               name,
               hash,
               track.videos,
               coords,
               recording_dates,
               street_names,
               track.renderer
             ),
           :ok <- Util.write_autogenerated_file(path, content) do
        module_name(hash)
      end
    end
  end

  @doc """
  Render the given trimmed sequence as a rendered video, but only make it
  available in the current runtime. No files are being written.
  """
  @spec dynamic_compile(Video.Track.t()) :: module() | {:error, binary()}
  def dynamic_compile(track) do
    with {hash, coords, rec_dates, street_names} <- Video.Track.render(track, street_names: false) do
      mod_name = Video.Generator.find_by_hash(hash)

      if is_nil(mod_name) do
        [{mod_name, _bytes}] =
          as_code(
            "dynamic_compile",
            hash,
            track.videos,
            coords,
            rec_dates,
            street_names,
            track.renderer
          )
          |> Enum.join()
          |> Code.compile_string()

        mod_name
      else
        mod_name
      end
    end
  end

  @spec module_name(Video.Track.hash()) :: module()
  def module_name(hash) when valid_hash(hash) do
    :"#{@autogen_module_name}#{hash}"
  end

  @polyline_interval_ms 1000.0 / 60.0
  @polyline_precision 6
  defp as_code(name, hash, sources, coords, recording_dates, street_names, renderer) do
    length_ms = coords |> List.last() |> Map.fetch!(:time_offset_ms)
    rendered = Video.Path.fully_rendered?(hash)
    bbox = Geo.CheapRuler.bbox(coords)

    polyline = %{
      polyline: Geo.Smoother.polyline(coords, @polyline_interval_ms, @polyline_precision),
      interval: @polyline_interval_ms,
      precision: @polyline_precision
    }

    quote do
      defmodule unquote(module_name(hash)) do
        @moduledoc """
        #{unquote(name)}

        # AUTOGENERATED. To update this file, run mix velo.videos.generate.
        # See Video.Rendered for functionality.
        """

        @behaviour Video.Rendered

        @impl Video.Rendered
        def name(), do: unquote(Macro.escape(name))
        @impl Video.Rendered
        def hash(), do: unquote(Macro.escape(hash))
        @impl Video.Rendered
        def length_ms(), do: unquote(Macro.escape(length_ms))
        @impl Video.Rendered
        def sources(), do: unquote(Macro.escape(sources))
        @impl Video.Rendered
        def rendered?(), do: unquote(rendered)
        @impl Video.Rendered
        def bbox(), do: unquote(bbox)
        @impl Video.Rendered
        def renderer(), do: unquote(renderer)
        @impl Video.Rendered
        def recording_dates(), do: unquote(recording_dates)
        @impl Video.Rendered
        # names derived from OpenStreetMap data, thus ODbL https://osmfoundation.org/wiki/Licence
        def street_names(), do: unquote(street_names)
        @impl Video.Rendered
        def coords(), do: unquote(coords)
        @impl Video.Rendered
        def polyline(), do: unquote(Macro.escape(polyline))
      end
    end
    |> Macro.to_string()
    |> Code.format_string!()
    |> Kernel.++(["\n"])
  end
end
